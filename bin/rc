#!/bin/bash

# rc - A convenient wrapper for rclone
# Can be both executed directly and sourced

rc() {
    # Function to print usage
    print_usage() {
        cat << EOF
RC - A convenient wrapper for rclone

Usage: rc [operation] [options] source destination

Operations:
    copy    Copy files (rclone copy)
    move    Move files (rclone move)
    sync    Sync directories (rclone sync)

Options:
    -h      Show this help message
    -t N    Set number of transfers (--transfers N)

Directory Behavior (like rsync):
    rc copy src/ dest/     # Copies contents of src to dest/
    rc copy src dest/      # Copies src directory to dest/src/

Examples:
    rc copy -t 8 *.txt gdrive:backup/      # Copy all txt files with 8 transfers
    rc move data-* od:archive/             # Move multiple files
    rc copy dir/ remote:backup/            # Copy directory contents
    rc sync docs/ gdrive:docs/             # Sync contents
    rc copy remote1:docs/ remote2:backup/  # Copy between remotes

Note: 
- Progress is enabled by default
- Directory behavior matches rsync (trailing slash matters)
- Remotes should be configured using 'rclone config' first
- For remote-to-remote transfers, consider using -t with higher value
EOF
    }

    # Function to check if a path is remote
    is_remote_path() {
        [[ "$1" == *:* ]]
    }

    # Function to extract directory name from a path
    get_dirname() {
        local path="$1"
        
        # Handle remote paths (contains colon)
        if is_remote_path "$path"; then
            # Extract the part after the colon
            local remote_part="${path#*:}"
            # Split on last /
            echo "${remote_part##*/}"
        else
            # Local path
            basename "${path%/}"
        fi
    }

    # Function to check if a remote path is a directory (has trailing slash or empty)
    is_remote_dir() {
        local path="$1"
        # If path has trailing slash or is just a remote root (e.g., "gdrive:"), it's a directory
        [[ "$path" == */ ]] || [[ "$path" =~ ^[^:]+:$ ]]
    }

    # Function to safely execute command with proper quoting
    safe_execute() {
        local operation="$1"
        local rclone_opts="$2"
        local src="$3"
        local dest="$4"
        
        # Use arrays to properly handle arguments with spaces and special chars
        local cmd=(rclone "$operation" $rclone_opts "$src" "$dest")
        echo "Executing: ${cmd[@]}"
        "${cmd[@]}"
        return $?
    }

    # Show help if no arguments or -h
    if [ $# -eq 0 ] || [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
        print_usage
        return 0
    fi

    # Initialize variables
    local operation=""
    local rclone_opts=(-P)  # Default options as array - just -P for progress
    local sources=()
    local destination=""
    local args=("$@")
    local i=0

    # Parse operation (first argument)
    case "${args[0]}" in
        copy|move|sync)
            operation="${args[0]}"
            ;;
        *)
            echo "Error: Invalid operation '${args[0]}'"
            print_usage
            return 1
            ;;
    esac
    ((i++))

    # Parse options first
    while [ $i -lt ${#args[@]} ]; do
        case "${args[i]}" in
            -t)
                ((i++))
                if [ $i -lt ${#args[@]} ] && [[ "${args[i]}" =~ ^[0-9]+$ ]]; then
                    rclone_opts+=(--transfers "${args[i]}")
                    ((i++))
                else
                    echo "Error: -t requires a number"
                    print_usage
                    return 1
                fi
                ;;
            *)
                break
                ;;
        esac
    done

    # Collect sources and destination
    local last_idx=$((${#args[@]} - 1))
    while [ $i -lt $last_idx ]; do
        sources+=("${args[i]}")
        ((i++))
    done

    # Get destination from the last argument
    if [ $i -eq $last_idx ]; then
        destination="${args[i]}"
    fi

    # Verify we have sources and destination
    if [ ${#sources[@]} -eq 0 ]; then
        echo "Error: Source must be specified"
        print_usage
        return 1
    fi
    
    if [ -z "$destination" ]; then
        echo "Error: Destination must be specified for $operation operation"
        print_usage
        return 1
    fi

    # Check if this is a remote-to-remote transfer
    if is_remote_path "${sources[0]}" && is_remote_path "$destination"; then
        # For remote-to-remote transfers, suggest higher transfer count if not set
        if ! [[ " ${rclone_opts[*]} " =~ " --transfers " ]]; then
            echo "Note: For remote-to-remote transfers, consider using -t option to set higher transfer count"
        fi
    fi

    # Handle directory behavior for copy/move/sync operations
    for ((j=0; j<${#sources[@]}; j++)); do
        local src="${sources[j]}"
        
        # Determine if this is a directory path without trailing slash
        local is_dir=false
        local has_trailing_slash=false
        
        # Check if path has a trailing slash
        if [[ "$src" == */ ]]; then
            has_trailing_slash=true
        fi
        
        # Note: If source is a wildcard pattern, is_dir and has_trailing_slash
        # might not be accurate, but we'll handle it in the file existence check
        
        # For local paths, check if it's a directory
        if ! is_remote_path "$src" && [[ ! "$src" == *[*?]* ]]; then  # Skip check for paths with wildcards
            if [ -d "${src%/}" ]; then
                is_dir=true
            elif [ -e "${src%/}" ]; then
                # It exists but is not a directory (might be a file)
                is_dir=false
            else
                # Path doesn't exist
                echo "Warning: Source path doesn't exist: $src"
                continue
            fi
        elif is_remote_path "$src"; then
            # For remote paths, we infer from the trailing slash (rsync-like behavior)
            # Only assume it's a directory if it has a trailing slash or is a remote root
            is_dir=is_remote_dir "$src"
        else
            # This is a local path with wildcards
            # We'll let rclone handle this directly
            safe_execute "$operation" "${rclone_opts[*]}" "$src" "$destination"
            local status=$?
            if [ $status -ne 0 ]; then
                echo "Error: rclone command failed with status $status"
                return $status
            fi
            # Skip further processing for this wildcard source
            continue
        fi
        
        if [ "$is_dir" = true ] && [ "$has_trailing_slash" = false ]; then
            # No trailing slash on directory, copy the directory itself
            # Get directory name
            local dirname=$(get_dirname "$src")
            # Update the destination for this source
            local new_dest="${destination%/}/$dirname"
            
            # Execute command safely
            safe_execute "$operation" "${rclone_opts[*]}" "${src%/}" "$new_dest"
            local status=$?
            if [ $status -ne 0 ]; then
                echo "Error: rclone command failed with status $status"
                return $status
            fi
        else
            # For files or directories with trailing slash, copy directly to destination
            safe_execute "$operation" "${rclone_opts[*]}" "$src" "$destination"
            local status=$?
            if [ $status -ne 0 ]; then
                echo "Error: rclone command failed with status $status"
                return $status
            fi
        fi
    done

    echo "Operation completed successfully"
    return 0
}

# If the script is being executed directly (not sourced),
# run the function with all arguments
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    rc "$@"
fi